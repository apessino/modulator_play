//!
//! # Extended primitives
//!
//! Customized version of gfx_graphics::GfxGraphics that gives us public access to the values
//! in the rendering context and adds custom rendering for prims, including thickness and color
//! blending, smooth connecting geometry, curve rendering and more

use cgmath::prelude::*;
use cgmath::{vec2, vec4, Basis2, Decomposed, Matrix2, Vector2, Vector4};

type Vec2 = Vector2<f32>;
type Vec4 = Vector4<f32>;
type Mat2 = Matrix2<f32>;
type Bas2 = Basis2<f32>;
type Dec2 = Decomposed<Vec2, Bas2>;

use num_complex::Complex32;

use std::f32;
use std::f32::consts::*;
use std::slice::from_raw_parts;

use bezier::{vec2_in_bounds, vec2_norm_or_zero, CubicCurve};

//
//  Geometry generators and utilities
//

/// Generate an n-gon of `sides` sides, side length scaled down by `slide_scale`, based off the
/// draw parameters `with` and transformed by the decomposed translate/rotate/scale `trs` - the
/// vertices of the polygon are generated by rotating the unit vector `from` (unit y if `None`)
/// around the unit circle at the origin and transforming the result by trs.
pub fn n_gon(
    sides: usize,
    side_scale: f32,
    with: DrawParms,
    trs: &Dec2,
    from: Option<Vec2>,
) -> (Vec<[Vec2; 2]>, Vec<DrawParms>) {
    let mut lines = vec![[vec2(0.0, 0.0); 2]; sides];
    let parms = vec![with; sides];

    let angle = PI * 2.0 / sides as f32;
    let ss = side_scale.max(0.001).min(1.0);

    let nn = if let Some(f) = from {
        f
    } else {
        vec2(0.0, -1.0)
    }; // starting vector
    let mut v0 = trs.disp + trs.transform_vector(nn);

    for i in 0..sides {
        let an = angle * (i + 1) as f32;
        let (sn, cs) = an.sin_cos();

        let v1 = vec2(nn.x * cs + nn.y * sn, nn.y * cs - nn.x * sn);
        let v1 = trs.disp + trs.transform_vector(v1);

        if ss < 1.0 {
            let cn = v0 + (v1 - v0) * 0.5;
            lines[i] = [cn + (v0 - cn) * ss, cn + (v1 - cn) * ss];
        } else {
            lines[i] = [v0, v1];
        }
        v0 = v1;
    }

    (lines, parms)
}

//
//  Draw parameters for custom primitives
//

/// Drawing styles available for each end cap
#[derive(Copy, Clone, Debug)]
pub enum CapStyle {
    Round(u16),  // rounded end cap with given subdivisions
    Square(f32), // squared end cap, to given distance (0.0 == use thickness)
    None,        // no cap
}

/// Line segment rendering parameters
#[derive(Copy, Clone, Debug)]
pub struct DrawParms {
    pub color: [Color; 2],   // colors at time 0.0 and 1.0
    pub thickness: [f32; 2], // thickness (on each side) at time 0.0 and 1.0
    pub cap: [CapStyle; 2],  // end cap style at 0.0 and 1.0
    pub connect_subs: u16,   // subdivisions to connect to next line in a set (0 to disable)
}

impl DrawParms {
    /// Build a draw parameter record
    pub fn new() -> Self {
        DrawParms {
            color: [[1.0; 4], [1.0; 4]],
            thickness: [1.0, 1.0],
            cap: [CapStyle::None, CapStyle::None],
            connect_subs: 16,
        }
    }

    /// Builder: set the color
    pub fn color(mut self, c: [Color; 2]) -> Self {
        self.color = c;
        self
    }
    /// Builder: set the thickness
    pub fn thickness(mut self, t: [f32; 2]) -> Self {
        self.thickness = t;
        self
    }
    /// Builder: set the endpoint style
    pub fn cap(mut self, c: [CapStyle; 2]) -> Self {
        self.cap = c;
        self
    }
    /// Builder: set number of subdivisions for the connector (0 = no connector)
    pub fn connect_subs(mut self, n: u16) -> Self {
        self.connect_subs = n;
        self
    }
}

//
//  Extra parameters for curve rendering
//

/// Record returned by the `PrimGraphics` `draw` method reflecting the result of querying
/// for curve features, always `None` if given `tolerance` of 0
#[derive(Copy, Clone, Debug)]
pub enum CurveQueryResult {
    /// Found a control point within tolerance (highest priority)
    Control {
        k: usize,      // index of the control point [0..4]
        pt: Vec2,      // control point location
        distance: f32, // distance to query point
    },
    /// Found a control handle point within tolerance
    Handle {
        k: usize,      // index of the handle [0..1]
        pt: Vec2,      // point on handle location
        time: f32,     // time along handle of point location
        distance: f32, // distance to query point
    },
    /// Found a point on a linear sample approximation segment within tolerance
    Sample {
        k: usize,      // index of sample containing the closest point on its linear approximation
        pt: Vec2,      // point on linear approximation of curve
        time: f32,     // time along the approximation sample line
        distance: f32, // distance to query point
    },
    None,
}

impl CurveQueryResult {
    fn new() -> Self {
        CurveQueryResult::None
    }
}

/// Settings used to draw a curve
#[derive(Copy, Clone, Debug)]
pub struct CurveDrawParms {
    pub parms: DrawParms, // overall color, thickness, start/end caps to draw the curve
    pub segment_scale: f32, // used to scale the endpoints of each line segment generated

    pub extra_features: bool, // if not set all extra render options below are disabled
    pub features_if: bool, // if set, enabled features other than curve drawn only if pt in bounds
    pub samples: bool,     // draw the sample points
    pub normals: bool,     // draw the normals at the sample points
    pub tangents: bool,    // draw the tangents at the sample points
    pub bounds: bool,      // draw the sample bounding box
    pub controls: bool,    // draw the control points/handles
    pub feature_info: bool, // print extended feature info, if found

    pub tolerance: f32, // distance range for searches

    pub sample_radius: f32,  // radius for sample points
    pub control_radius: f32, // radius for control points

    pub circle_subs: u16, // subdivisions for circles used to draw samples and handles

    pub vlen: f32, // length for visualization of normals/tangents

    pub lthick: f32, // thickness for normal and tangent lines
    pub cthick: f32, // thickness for control handles

    pub samplc: Color, // color for sample points, normals, control points/handles
    pub normlc: Color, // color for tangents, bounds
    pub selecc: Color, // color for selected items
}

impl CurveDrawParms {
    /// Make a new curve rendering settings record
    pub fn new() -> Self {
        Self {
            parms: DrawParms::new()
                .cap([CapStyle::Round(8); 2])
                .connect_subs(0),
            segment_scale: 1.0,

            extra_features: false,
            features_if: true,
            samples: true,
            normals: false,
            tangents: false,
            bounds: true,
            controls: true,
            feature_info: true,

            tolerance: 8.0,

            sample_radius: 3.0,
            control_radius: 5.0,

            circle_subs: 10,

            vlen: 30.0,

            lthick: 1.5,
            cthick: 2.0,

            samplc: color_from(0x8f_34_fe_bb),
            normlc: color_from(0xaf_42_67_5a),
            selecc: color_from(0xff_ff_ff_00),
        }
    }

    /// Builder: overall color, thickness, caps to draw the curve
    pub fn parms(mut self, p: DrawParms) -> Self {
        self.parms = p;
        self
    }
    /// Builder: scaling factor for rendering line segments
    pub fn segment_scale(mut self, n: f32) -> Self {
        self.segment_scale = n;
        self
    }

    /// Builder: if not set all other render features are disabled, regardless of settings
    pub fn extra_features(mut self, s: bool) -> Self {
        self.extra_features = s;
        self
    }
    /// Builder: if set, enabled features other than curve drawn only if pt in bounds
    pub fn features_if(mut self, s: bool) -> Self {
        self.features_if = s;
        self
    }
    /// Builder: draw the sample points
    pub fn samples(mut self, s: bool) -> Self {
        self.samples = s;
        self
    }
    /// Builder: draw the normals at the sample points
    pub fn normals(mut self, s: bool) -> Self {
        self.normals = s;
        self
    }
    /// Builder: draw the tangents at the sample points
    pub fn tangents(mut self, s: bool) -> Self {
        self.tangents = s;
        self
    }
    /// Builder: draw the sample bounding box
    pub fn bounds(mut self, s: bool) -> Self {
        self.bounds = s;
        self
    }
    /// Builder: draw the control points/handles
    pub fn controls(mut self, s: bool) -> Self {
        self.controls = s;
        self
    }
    /// Builder: print extended feature info, if found
    pub fn feature_info(mut self, s: bool) -> Self {
        self.feature_info = s;
        self
    }

    /// Builder: distance range for searches
    pub fn tolerance(mut self, n: f32) -> Self {
        self.tolerance = n;
        self
    }

    /// Builder: radius for sample points
    pub fn sample_radius(mut self, n: f32) -> Self {
        self.sample_radius = n;
        self
    }
    /// Builder: radius for control points
    pub fn control_radius(mut self, n: f32) -> Self {
        self.control_radius = n;
        self
    }

    /// Builder: subdivisions for sample/control circles
    pub fn circle_subs(mut self, n: u16) -> Self {
        self.circle_subs = n;
        self
    }

    /// Builder: length for visualization of normals/tangents
    pub fn vlen(mut self, n: f32) -> Self {
        self.vlen = n;
        self
    }

    /// Builder: thickness for normal and tangent lines
    pub fn lthick(mut self, n: f32) -> Self {
        self.lthick = n;
        self
    }
    /// Builder: thickness for control handles
    pub fn cthick(mut self, n: f32) -> Self {
        self.cthick = n;
        self
    }

    /// Builder: color for sample points, control points/handles
    pub fn samplc(mut self, c: Color) -> Self {
        self.samplc = c;
        self
    }
    /// Builder: color for normals, tangents
    pub fn normlc(mut self, c: Color) -> Self {
        self.normlc = c;
        self
    }
    /// Builder: color for selected/highlighted item
    pub fn selecc(mut self, c: Color) -> Self {
        self.selecc = c;
        self
    }

    /// Find the closest control, point on control handle or point on curve, in order of priority
    pub fn find(&self, curve: &mut CubicCurve, p: Vec2) -> CurveQueryResult {
        assert!(self.tolerance < f32::INFINITY);
        curve.validate();

        if self.tolerance <= 0.0 {
            return CurveQueryResult::new();
        }

        let (k, distance) = self.control(curve, p);
        if distance <= self.tolerance {
            return CurveQueryResult::Control {
                k,
                pt: curve.control_points()[k],
                distance,
            };
        }

        let (k, pt, time, distance) = self.handle(curve, p);
        if distance <= self.tolerance {
            return CurveQueryResult::Handle {
                k,
                pt,
                time,
                distance,
            };
        }

        if vec2_in_bounds(p, &curve.bounds(self.tolerance)) {
            let (k, pt, time, distance) = self.curve(curve, p);
            if let Some(j) = k {
                if distance <= self.tolerance {
                    return CurveQueryResult::Sample {
                        k: j,
                        pt,
                        time,
                        distance,
                    };
                }
            }
        }

        return CurveQueryResult::new();
    }

    // Query component search
    fn control(&self, curve: &mut CubicCurve, p: Vec2) -> (usize, f32) {
        if self.tolerance > 0.0 && self.controls {
            curve.closest_control_point_to(p)
        } else {
            (0, f32::INFINITY)
        }
    }
    fn handle(&self, curve: &mut CubicCurve, p: Vec2) -> (usize, Vec2, f32, f32) {
        if self.tolerance > 0.0 && self.controls {
            curve.closest_handle_to(p)
        } else {
            (0, vec2(0.0, 0.0), 0.0, f32::INFINITY)
        }
    }
    fn curve(&self, curve: &mut CubicCurve, p: Vec2) -> (Option<usize>, Vec2, f32, f32) {
        if self.tolerance > 0.0 {
            curve.closest_to(p)
        } else {
            (None, vec2(0.0, 0.0), 0.0, f32::INFINITY)
        }
    }
}

//
//  Customized piston graphics environment to support our extended primitives
//

pub struct PrimGraphics<'a, R, C>
where
    R: gfx::Resources + 'a,
    C: gfx::CommandBuffer<R> + 'a,
    R::Buffer: 'a,
    R::Shader: 'a,
    R::Program: 'a,
    R::Texture: 'a,
    R::Sampler: 'a,
{
    pub encoder: &'a mut gfx::Encoder<R, C>, // data taken straight from piston graphics
    pub output_color: &'a gfx::handle::RenderTargetView<R, Srgba8>,
    pub output_stencil: &'a gfx::handle::DepthStencilView<R, DepthStencil>,

    pub c2d: &'a mut Prims2d<R>, // our custom 2d buffers

    pub debug_wireframe: bool,        // draw extra debug lines
    pub debug_wireframe_color: Color, // color to use for debug lines
    pub debug_faces: bool,            // draw all faces in alternating translucent colors

    flip_debug_color: bool, // internal state to choose alternating quad colors
    fill_center: Option<Vec2>, // internal state, if Some(center) then fill mode enabled
    fill_color: Color,      // internal state, color to use for center point when fillings

    lerp_exp: Option<f32>, // internal state - linear mapping to use with connectors
}

impl<'a, R, C> PrimGraphics<'a, R, C>
where
    R: gfx::Resources,
    C: gfx::CommandBuffer<R>,
{
    pub fn new(
        encoder: &'a mut gfx::Encoder<R, C>,
        output_color: &'a gfx::handle::RenderTargetView<R, Srgba8>,
        output_stencil: &'a gfx::handle::DepthStencilView<R, DepthStencil>,
        c2d: &'a mut Prims2d<R>,
    ) -> Self {
        PrimGraphics {
            encoder: encoder,
            output_color: output_color,
            output_stencil: output_stencil,
            c2d: c2d,

            debug_wireframe: false,
            debug_wireframe_color: [0.0, 0.0, 0.0, 1.0],
            debug_faces: false,

            flip_debug_color: false,
            fill_center: None,
            fill_color: [0.0; 4],

            lerp_exp: None,
        }
    }

    /// Draw a line
    pub fn draw_line(&mut self, ps: [Vec2; 2], parms: &DrawParms, c: &Context) {
        let (ln, nn) = line_parms(ps);

        let p0 = match parms.cap[0] {
            CapStyle::Square(n) => ps[0] - ln * if n > 0.0 { n } else { parms.thickness[0] },
            _ => ps[0],
        };
        let p1 = match parms.cap[1] {
            CapStyle::Square(n) => ps[1] + ln * if n > 0.0 { n } else { parms.thickness[1] },
            _ => ps[1],
        };

        let n0 = nn * parms.thickness[0];
        let n1 = nn * parms.thickness[1];

        self.add_quad(&[p0 - n0, p0 + n0, p1 - n1, p1 + n1], parms.color, c);

        match parms.cap[0] {
            CapStyle::Round(sub) => self.round_t(ps[0], nn, sub, 0, parms, c),
            _ => (),
        };
        match parms.cap[1] {
            CapStyle::Round(sub) => self.round_t(ps[1], nn, sub, 1, parms, c),
            _ => (),
        };
    }

    /// Draw the a set of lines generating intermediate parameters from `parm` automatically,
    /// distributing the given parameter space over the estimated linear length of the set.
    ///
    /// If `closed` is true the endpoints are connected. The `scale` parameter can be used to
    /// scale the internal line segments, in conjunction with `parm.connect_subs` this adjusts
    /// the overall curvature of the connections.
    ///
    /// The `scale` parameter is interpreted as follows: 0.0 = automatic absolute (uses
    /// current thickness), (0.0, 1.0] = proportional scale factor around segment centerpoint,
    /// and >1.0 = absolute scaling by the given amount, at each end.
    ///
    /// The `lerp_exp` value is used to map the linear blend factor generated for color and
    /// thickness blending from linear to exponential - linear exp 1.0 is used if `None`,
    /// otherwise the value is used as the exponent to raise the blending factor to.
    pub fn draw_lines_auto(
        &mut self,
        lines: &[[Vec2; 2]],
        parm: DrawParms,
        scale: f32,
        closed: bool,
        filled: bool,
        lerp_exp: Option<f32>,
        c: &Context,
    ) {
        let n = lines.len();
        if n == 0 {
            return;
        }

        let (ls, ln) = corrected_lines(&lines, scale, &parm, closed, lerp_exp);
        let ps = auto_parms(&ls, ln, &parm, closed, lerp_exp);

        self.lerp_exp = lerp_exp;
        if filled {
            self.draw_lines_filled(&ls, &ps, c);
        } else {
            self.draw_lines(&ls, &ps, c);
        }
        self.lerp_exp = None;
    }

    /// Draw a set of lines
    pub fn draw_lines(&mut self, lines: &[[Vec2; 2]], parms: &[DrawParms], c: &Context) {
        let n = lines.len();
        assert_eq!(n, parms.len());

        for i in 0..n {
            self.draw_line(lines[i], &parms[i], c);

            if parms[i].connect_subs > 0 {
                let j = if i < n - 1 { i + 1 } else { 0 };

                let (_, nn0) = line_parms(lines[i]);
                let (_, nn1) = line_parms(lines[j]);

                let n0 = nn0 * parms[i].thickness[1];
                let f = [lines[i][1] + n0, lines[i][1] - n0];

                let n1 = nn1 * parms[j].thickness[0];
                let t = [lines[j][0] + n1, lines[j][0] - n1];

                let cols = [parms[i].color[1], parms[j].color[0]];
                self.connect(f, t, parms[i].connect_subs, cols, c);
            }
        }
    }

    /// Draw the set of lines, also fill out to the center (works best if closed, of course)
    pub fn draw_lines_filled(&mut self, lines: &[[Vec2; 2]], parms: &[DrawParms], c: &Context) {
        let (center, color) = fill_parms(lines, parms);

        self.fill_center = Some(tv(center, c.transform));
        self.fill_color = color; // already in linear space

        self.draw_lines(lines, parms, c);

        self.fill_center = None;
    }

    /// Draw a curve. Notice that `curve` is mutably borrowed because its validation might cause
    /// the sample data to be recomputed. The `lerp_exp` parameter has the same meaning as with
    /// the `draw_lines_auto` method: it Some(e) then e is the exponent used to map the linear
    /// blend factor into an exponential curve
    pub fn draw_curve(
        &mut self,
        curve: &mut CubicCurve,
        parms: &CurveDrawParms,
        query_loc: Vec2,
        query_result: &CurveQueryResult,
        lerp_exp: Option<f32>,
        c: &Context,
    ) {
        curve.validate(); // must make sure the curve is valid or its methods will panic

        let smp = curve.samples();
        let n = smp.len();

        if n < 2 {
            return;
        }

        let mut ls = Vec::with_capacity(n - 1);
        for i in 0..n - 1 {
            ls.push([smp[i], smp[i + 1]]);
        }

        self.draw_lines_auto(
            &ls,
            parms.parms,
            parms.segment_scale,
            false,
            false,
            lerp_exp,
            c,
        );

        if !parms.extra_features {
            return;
        }

        if !parms.features_if || curve.in_bounds(query_loc, parms.sample_radius) {
            if parms.bounds {
                self.draw_rect(
                    curve.bounds(parms.sample_radius),
                    parms.samplc,
                    parms.lthick,
                    false,
                    c,
                );
            }

            if parms.samples {
                for p in smp {
                    self.draw_circle(*p, parms.sample_radius, parms.samplc, parms.circle_subs, c);
                }
            }

            if let CurveQueryResult::Sample {
                k: _,
                pt,
                time: _,
                distance: _,
            } = query_result
            {
                self.draw_circle(
                    *pt,
                    parms.sample_radius * 2.0,
                    parms.selecc,
                    parms.circle_subs,
                    c,
                );
            }

            if parms.normals || parms.tangents {
                let smd = curve.sampledata();
                let pm = DrawParms {
                    color: [parms.samplc, parms.normlc],
                    thickness: [parms.lthick * 0.5, parms.lthick * 0.5],
                    ..DrawParms::new()
                };

                for i in 0..n {
                    if parms.normals {
                        self.draw_line(
                            [smp[i], smp[i] + curve.tangent_at_(smd[i].n) * parms.vlen],
                            &pm,
                            &c,
                        );
                    }
                    if parms.tangents {
                        self.draw_line([smp[i], smp[i] + smd[i].n * parms.vlen], &pm, &c);
                    }
                }
            }
        }

        if parms.controls {
            // Get the current selection from the query
            let sel_h = if let CurveQueryResult::Handle {
                k,
                pt: _,
                time: _,
                distance: _,
            } = query_result
            {
                *k
            } else {
                2 // never
            };
            let sel_c = if let CurveQueryResult::Control {
                k,
                pt: _,
                distance: _,
            } = query_result
            {
                *k
            } else {
                5 // never
            };

            let cs = curve.control_points();
            let pm = DrawParms {
                color: [parms.samplc, parms.samplc],
                thickness: [parms.cthick * 0.5, parms.cthick * 0.5],
                ..DrawParms::new()
            };
            let hc = [parms.selecc, parms.selecc];

            self.draw_line(
                [cs[0], cs[1]],
                &DrawParms {
                    color: if sel_h != 0 { pm.color } else { hc },
                    ..pm
                },
                &c,
            );
            self.draw_line(
                [cs[3], cs[2]],
                &DrawParms {
                    color: if sel_h != 1 { pm.color } else { hc },
                    ..pm
                },
                &c,
            );

            for i in 0..4 {
                self.draw_circle(
                    cs[i],
                    if sel_c != i {
                        parms.control_radius
                    } else {
                        parms.control_radius * 1.5
                    },
                    if sel_c != i {
                        parms.samplc
                    } else {
                        parms.selecc
                    },
                    parms.circle_subs,
                    c,
                );
            }
        }
    }

    /// Draw a circle
    pub fn draw_circle(&mut self, center: Vec2, radius: f32, color: Color, subs: u16, c: &Context) {
        let pm = DrawParms {
            color: [color, color],
            thickness: [radius, radius],
            cap: [CapStyle::None, CapStyle::None],
            connect_subs: 0,
        };

        let norm = vec2(0.0, 1.0);
        let subs = u16::max(2, subs / 2);

        self.round_t(center, norm, subs, 0, &pm, c);
        self.round_t(center, norm, subs, 1, &pm, c);
    }

    /// Draw a rectangle
    pub fn draw_rect(
        &mut self,
        bounds: [Vec2; 2],
        color: Color,
        thickness: f32,
        filled: bool,
        c: &Context,
    ) {
        let ht = thickness / 2.0;
        let pm = DrawParms {
            color: [color, color],
            thickness: [ht, ht],
            cap: [CapStyle::Square(0.0), CapStyle::None],
            connect_subs: 0,
        };

        let tl = bounds[0];
        let br = bounds[1];
        let tr = vec2(br.x, tl.y);
        let bl = vec2(tl.x, br.y);

        let ln = [
            [tl, vec2(br.x - ht, tl.y)],
            [tr, vec2(br.x, br.y - ht)],
            [br, vec2(tl.x + ht, br.y)],
            [bl, vec2(tl.x, tl.y + ht)],
        ];
        if filled {
            self.draw_lines_filled(&ln, &[pm; 4], &c);
        } else {
            self.draw_lines(&ln, &[pm; 4], &c);
        }
    }

    /// Get the quad drawing debug color so they alternate
    fn next_quad_colors(&mut self) -> [Color; 2] {
        debug_assert!(self.debug_faces);

        self.flip_debug_color = !self.flip_debug_color;
        if self.flip_debug_color {
            [[0.0, 0.7, 0.0, 0.7], [0.0, 0.7, 0.0, 0.7]]
        } else {
            [[0.7, 0.0, 0.0, 0.7], [0.7, 0.0, 0.0, 0.7]]
        }
    }

    /// Add a quad to render buffer
    fn add_quad(&mut self, quad: &[Vec2; 4], mut cl: [Color; 2], c: &Context) {
        let add_verts = if let Some(_) = self.fill_center { 9 } else { 6 };
        self.validate_state(&c.draw_state, add_verts);

        if self.debug_faces {
            cl = self.next_quad_colors();
        }

        let c0 = gamma_srgb_to_linear(cl[0]);
        let c1 = gamma_srgb_to_linear(cl[1]);

        let q0 = tv(quad[0], c.transform);
        let q1 = tv(quad[1], c.transform);
        let q2 = tv(quad[2], c.transform);
        let q3 = tv(quad[3], c.transform);

        let verts = [q0, q1, q2, q3, q2, q1];
        let vcols = [c0, c0, c1, c1, c1, c0];

        unsafe {
            // draw the main quad
            self.encoder
                .update_buffer(
                    &self.c2d.pos,
                    from_raw_parts(verts.as_ptr() as *const PositionFormat, 6),
                    self.c2d.offset,
                ).unwrap();
            self.encoder
                .update_buffer(
                    &self.c2d.color,
                    from_raw_parts(vcols.as_ptr() as *const ColorFormat, 6),
                    self.c2d.offset,
                ).unwrap();
            self.c2d.offset += 6;
        }

        if let Some(center) = self.fill_center {
            // if fill is on, draw a tri to cached center
            let (v0, v1) = towards_center(center, [q0, q1, q2, q3]);
            unsafe {
                self.encoder
                    .update_buffer(
                        &self.c2d.pos,
                        from_raw_parts([center, v0, v1].as_ptr() as *const PositionFormat, 3),
                        self.c2d.offset,
                    ).unwrap();
                self.encoder
                    .update_buffer(
                        &self.c2d.color,
                        from_raw_parts([self.fill_color, c0, c1].as_ptr() as *const ColorFormat, 3),
                        self.c2d.offset,
                    ).unwrap();
                self.c2d.offset += 3;
            }
        }

        if self.debug_wireframe {
            self.line_debug([quad[0], quad[1]], c);
            self.line_debug([quad[1], quad[3]], c);
            self.line_debug([quad[3], quad[2]], c);
            self.line_debug([quad[2], quad[0]], c);
        }
    }

    /// Generate quads connecting a segment to another - uses the Hise Vector Screw
    fn connect_t(
        &mut self,
        f: [Vec2; 2],    // from segment
        t: [Vec2; 2],    // to segment
        about: Vec2,     // initial pivot point
        subs: u16,       // number of quads to generate
        col: [Color; 2], // colors at f and t
        c: &Context,
    ) {
        let cn0 = corrected_pivot([f[0], t[0]], about);
        let cn1 = corrected_pivot([f[1], t[1]], about);

        let f0c = complex(f[0]) - cn0;
        let t0c = complex(t[0]) - cn0;
        let f1c = complex(f[1]) - cn1;
        let t1c = complex(t[1]) - cn1;

        let d0 = f0c.inv() * t0c;
        let d1 = f1c.inv() * t1c;

        let cf = as_vec4(col[0]); // colors for interpolation
        let ct = as_vec4(col[1]);

        let mut q0 = complex(f[0]);
        let mut q1 = complex(f[1]);

        let mut c0 = as_color(cf);

        for i in 0..subs {
            let mut ex = (i + 1) as f32 / subs as f32; // exponent to interpolate over
            if let Some(lex) = self.lerp_exp {
                ex = ex.powf(lex);
            }
            let c1 = col_lerp(ex, cf, ct);

            let p0 = if d0.im >= 0.0 {
                d0.powf(ex)
            } else {
                d0.conj().powf(ex).conj() // map to positive and back
            };
            let p1 = if d1.im >= 0.0 {
                d1.powf(ex)
            } else {
                d1.conj().powf(ex).conj()
            };

            let p0 = f0c * p0 + cn0;
            let p1 = f1c * p1 + cn1;

            self.add_quad(
                &[
                    vec2(q0.re, q0.im),
                    vec2(q1.re, q1.im),
                    vec2(p0.re, p0.im),
                    vec2(p1.re, p1.im),
                ],
                [c0, c1],
                c,
            );

            q0 = p0;
            q1 = p1;
            c0 = c1;
        }
    }

    /// Connect segment f to segment t with an arc
    fn connect(&mut self, f: [Vec2; 2], t: [Vec2; 2], subs: u16, col: [Color; 2], c: &Context) {
        assert!(subs > 0);

        let df = f[1] - f[0];
        let dt = t[1] - t[0];

        // Find the intersection of the line segments as the initial pivot point
        let mat = Mat2::new(df.x, df.y, dt.x, dt.y);
        let det = mat.determinant();

        if det.abs() < 0.001 {
            self.add_quad(&[f[0], f[1], t[0], t[1]], col, c);
        } else if let Some(mat) = mat.invert() {
            self.connect_t(
                f,
                t,
                f[0] + (f[1] - f[0]) * (mat * (t[0] - f[0])).x,
                subs,
                col,
                c,
            );
        }
    }

    /// Draw a rounded cap at `at`
    fn round_t(
        &mut self,
        at: Vec2,
        normal: Vec2, // normal at endpoint
        subs: u16,    // desired subdivisions
        index: usize, // 0/1 index to get extra endpoint data
        parms: &DrawParms,
        c: &Context,
    ) {
        if subs == 0 {
            return;
        }

        let p0 = tv(at, c.transform); // base
        let p1 = tv(at + normal * parms.thickness[index], c.transform); // moving points

        let mut p = [p0, p1, vec2(0.0, 0.0)];
        let mut cols = [gamma_srgb_to_linear(parms.color[index]); 3];

        let tris = subs as usize; // number of generated triangles
        let angle = if index == 0 {
            PI / tris as f32
        } else {
            -PI / tris as f32
        };

        self.validate_state(&c.draw_state, 3 * tris);

        for i in 0..tris {
            let an = angle * (i + 1) as f32;
            let (sn, cs) = an.sin_cos();

            let n2 = vec2(normal.x * cs - normal.y * sn, normal.y * cs + normal.x * sn);
            p[2] = tv(at + n2 * parms.thickness[index], c.transform);

            if self.debug_faces {
                cols = [gamma_srgb_to_linear(self.next_quad_colors()[0]); 3];
            }

            unsafe {
                self.encoder
                    .update_buffer(
                        &self.c2d.pos,
                        from_raw_parts(p.as_ptr() as *const PositionFormat, 3),
                        self.c2d.offset,
                    ).unwrap();

                self.encoder
                    .update_buffer(
                        &self.c2d.color,
                        from_raw_parts(cols.as_ptr() as *const ColorFormat, 3),
                        self.c2d.offset,
                    ).unwrap();

                self.c2d.offset += 3;
            }

            p[1] = p[2];
        }

        if self.debug_wireframe {
            p = [at, at + normal * parms.thickness[index], vec2(0.0, 0.0)];
            for i in 0..tris {
                let an = angle * (i + 1) as f32;
                let sn = an.sin();
                let cs = an.cos();

                let n2 = vec2(normal.x * cs - normal.y * sn, normal.y * cs + normal.x * sn);
                p[2] = at + n2 * parms.thickness[index];

                self.line_debug([p[0], p[1]], c);
                self.line_debug([p[1], p[2]], c);
                self.line_debug([p[2], p[0]], c);

                p[1] = p[2];
            }
        }
    }

    /// Draw a debug line
    fn line_debug(&mut self, line: [Vec2; 2], c: &Context) {
        let (_, nn) = line_parms(line);
        let nn = nn * 0.6;

        let debug_wireframe = self.debug_wireframe; // clear so add_quad does not recurse
        let debug_faces = self.debug_faces;

        self.debug_wireframe = false;
        self.debug_faces = false;
        let cols = [self.debug_wireframe_color; 2];

        self.add_quad(
            &[line[0] - nn, line[0] + nn, line[1] - nn, line[1] + nn],
            cols,
            c,
        );

        self.debug_wireframe = debug_wireframe;
        self.debug_faces = debug_faces;
    }

    /// Check if a state change requires us to flush the primitives buffer
    fn validate_state(&mut self, draw_state: &DrawState, adding: usize) {
        if &self.c2d.draw_state != draw_state || self.c2d.offset + adding > BUFFER_SIZE * CHUNKS {
            self.flush();
            self.c2d.draw_state = *draw_state;
        }
    }

    /// FLush the current buffer by committing to the encoder
    fn flush(&mut self) {
        use draw_state::target::Rect;
        use std::u16;

        let &mut PrimGraphics {
            ref mut encoder,
            output_color,
            output_stencil,
            c2d:
                &mut Prims2d {
                    ref mut offset,
                    ref mut draw_state,
                    ref mut pos,
                    ref mut color,
                    ref mut colored,
                    ..
                },
            ..
        } = self;

        let (pso_colored, stencil_val) =
            colored.stencil_blend(draw_state.stencil, draw_state.blend);

        let scissor = match draw_state.scissor {
            None => Rect {
                x: 0,
                y: 0,
                w: u16::MAX,
                h: u16::MAX,
            },
            Some(r) => Rect {
                x: r[0] as u16,
                y: r[1] as u16,
                w: r[2] as u16,
                h: r[3] as u16,
            },
        };

        let data = pipe_colored::Data {
            pos: pos.clone(),
            color: color.clone(),
            blend_target: output_color.clone(),
            stencil_target: (output_stencil.clone(), (stencil_val, stencil_val)),
            blend_ref: [1.0; 4],
            scissor: scissor,
        };

        let slice = gfx::Slice {
            instances: None,
            start: 0,
            end: *offset as u32,
            buffer: gfx::IndexBuffer::Auto,
            base_vertex: 0,
        };
        encoder.draw(&slice, pso_colored, &data);
        *offset = 0;
    }
}

//
//  Color utilities
//

/// Return a color as a vec4
pub fn as_vec4(c: Color) -> Vec4 {
    vec4(c[0], c[1], c[2], c[3])
}
/// Return the vec4 as a color
pub fn as_color(v: Vec4) -> Color {
    [v.x, v.y, v.z, v.w]
}

/// Simple lerp between two colors
pub fn col_lerp(t: f32, a: Vec4, b: Vec4) -> Color {
    as_color(a + (b - a) * t)
}

/// Convert an argb 32-bit color into a graphics `Color`
pub fn color_from(argb: u32) -> Color {
    [
        ((argb & 0x00_ff_00_00) >> 16) as f32 / 255.0,
        ((argb & 0x00_00_ff_00) >> 8) as f32 / 255.0,
        (argb & 0x00_00_00_ff) as f32 / 255.0,
        ((argb & 0xff_00_00_00) >> 24) as f32 / 255.0,
    ]
}

/// Transform `v` by matrix `m`
fn tv(v: Vec2, m: Matrix2d) -> Vec2 {
    vec2(
        (m[0][0] * v.x as f64 + m[0][1] * v.y as f64 + m[0][2]) as f32,
        (m[1][0] * v.x as f64 + m[1][1] * v.y as f64 + m[1][2]) as f32,
    )
}

/// Return `v` as a complex number
fn complex(v: Vec2) -> Complex32 {
    Complex32::new(v.x, v.y)
}

/// Get direction and normal vectors for the given line
fn line_parms(line: [Vec2; 2]) -> (Vec2, Vec2) {
    let ln = vec2_norm_or_zero(line[1] - line[0]);
    let nn = vec2(-ln.y, ln.x);

    (ln, nn)
}

/// Scale the endpoints of a line segment about its center by scale[left, right]
fn line_scaled(line: [Vec2; 2], scale: [f32; 2]) -> [Vec2; 2] {
    let cn = line[0] + (line[1] - line[0]) * 0.5;
    [
        cn + (line[0] - cn) * scale[0],
        cn + (line[1] - cn) * scale[1],
    ]
}

/// Compute the corrected version of the lines - returns a vector of corrected lines and the
/// estimated total linear length of the new set
fn corrected_lines(
    lines: &[[Vec2; 2]],
    scale: f32,
    parm: &DrawParms,
    closed: bool,
    lerp_exp: Option<f32>,
) -> (Vec<[Vec2; 2]>, f32) {
    let n = lines.len();
    if n == 0 {
        return (vec![], 0.0);
    }

    let connected = parm.connect_subs > 0;

    // Calculate the total estimated linear length
    let mut len = 0.0;
    for i in 0..n {
        len += (lines[i][1] - lines[i][0]).magnitude();
    }
    if closed {
        len += (lines[0][0] - lines[n - 1][1]).magnitude();
    }

    // Now generate corrected lines, recompute the total length as we go
    let mut ls: Vec<[Vec2; 2]> = Vec::with_capacity(n); // converted lines
    let mut ln = 0.0; // new total estimated linear length

    let mut l = 0.0; // current position along the initial estimated length
    let thd = parm.thickness[1] - parm.thickness[0]; // linear thickness delta

    for i in 0..n {
        let ll = (lines[i][1] - lines[i][0]).magnitude(); // uncorrected length

        let mut t0 = l / len; // blend factor at each end of the line
        let mut t1 = (l + ll) / len;

        if let Some(lex) = lerp_exp {
            t0 = t0.powf(lex);
            t1 = t1.powf(lex);
        }

        let th_0 = parm.thickness[0] + thd * t0;
        let th_1 = parm.thickness[0] + thd * t1;

        let cl = corrected_line(lines[i], i, n, scale, [th_0, th_1]);

        ln += (cl[1] - cl[0]).magnitude(); // recalculate lengths as we go
        if connected && i > 0 {
            ln += (cl[0] - ls[i - 1][1]).magnitude();
        }

        ls.push(cl);
        l += ll;
    }

    if closed {
        ln += (ls[0][0] - ls[n - 1][1]).magnitude();
    }

    (ls, ln)
}

/// Given a `line`, its index `i`, the total number of lines `n`, the correction factor `scale`
/// and the thickness at line[0] and line[1] `thickness` calculate and return the line
/// corrected as determined by `scale`
fn corrected_line(
    line: [Vec2; 2],
    i: usize,
    n: usize,
    scale: f32,
    thickness: [f32; 2],
) -> [Vec2; 2] {
    if n == 1 {
        return line; // one line, no change in any mode
    }

    let mut c = line;

    // If scale in (0.0..1.0] then we apply proportional scaling
    if scale > 0.0 && scale <= 1.0 {
        if i == 0 {
            c = line_scaled(line, [1.0, scale]);
        } else if i == n - 1 {
            c = line_scaled(line, [scale, 1.0]);
        } else {
            c = line_scaled(line, [scale, scale]);
        }
    } else {
        let v = c[1] - c[0];
        let m = v[0].hypot(v[1]);
        let sz = 1.0 / m;

        if sz.is_finite() {
            let l0;
            let l1;

            let cn = c[0] + v * 0.5; // center of line
            let vn = v * sz; // normalized vector

            if scale > 1.0 {
                // absolute
                l0 = m * 0.5 - f32::min(m * 0.5, scale); // apply at most half a line length
                l1 = l0;
            } else {
                // scale <= 0.0, automatic
                l0 = m * 0.5 - f32::min(m * 0.5, thickness[0] * 1.2);
                l1 = m * 0.5 - f32::min(m * 0.5, thickness[1] * 1.2);
            }

            if i == 0 {
                c = [c[0], cn + vn * l1];
            } else if i == n - 1 {
                c = [cn - vn * l0, c[1]];
            } else {
                c = [cn - vn * l0, cn + vn * l1];
            }
        }
    }

    c
}

/// Derive a full set of draw parms interpolating over the line segments from `parm`
fn auto_parms(
    lines: &[[Vec2; 2]],
    tot_len: f32,
    parm: &DrawParms,
    closed: bool,
    lerp_exp: Option<f32>,
) -> Vec<DrawParms> {
    let n = lines.len();
    if n == 0 {
        return vec![];
    }

    let mut ps = vec![
        DrawParms {
            cap: [CapStyle::None, CapStyle::None],
            ..*parm
        };
        n
    ];

    ps[0].cap[0] = parm.cap[0]; // preserve the end caps at beginning and end
    ps[n - 1].cap[1] = parm.cap[1];

    if !closed {
        ps[n - 1].connect_subs = 0;
    }

    let mut len = 0.0;
    let connected = parm.connect_subs > 0;

    let c0 = as_vec4(parm.color[0]);
    let c1 = as_vec4(parm.color[1]);

    for i in 0..n {
        let mut t = len / tot_len;
        if let Some(lex) = lerp_exp {
            t = t.powf(lex);
        }

        ps[i].color[0] = col_lerp(t, c0, c1);
        ps[i].thickness[0] = parm.thickness[0] + (parm.thickness[1] - parm.thickness[0]) * t;

        len += (lines[i][1] - lines[i][0]).magnitude();

        let mut t = len / tot_len;
        if let Some(lex) = lerp_exp {
            t = t.powf(lex);
        }

        ps[i].color[1] = col_lerp(t, c0, c1);
        ps[i].thickness[1] = parm.thickness[0] + (parm.thickness[1] - parm.thickness[0]) * t;

        if connected && i < n - 1 {
            len += (lines[i + 1][0] - lines[i][1]).magnitude();
        }
    }

    ps
}

/// Calculate the center point of the given lines
fn fill_parms(lines: &[[Vec2; 2]], parms: &[DrawParms]) -> (Vec2, Color) {
    let mut center = vec2(0.0, 0.0);
    let mut color = vec4(0.0, 0.0, 0.0, 0.0);

    let n = lines.len();
    for i in 0..n {
        center += lines[i][0] + lines[i][1];
        color += as_vec4(parms[i].color[0]) + as_vec4(parms[i].color[1]);
    }

    (
        center / (n * 2) as f32,
        gamma_srgb_to_linear(as_color(color / (n * 2) as f32)),
    )
}

/// Get the points along cn..(q0/q1) and cn..(q2/q3) needed to make a center tri
fn towards_center(cn: Vec2, q: [Vec2; 4]) -> (Vec2, Vec2) {
    (
        if (q[0] - cn).magnitude2() < (q[1] - cn).magnitude2() {
            q[0]
        } else {
            q[1]
        },
        if (q[2] - cn).magnitude2() < (q[3] - cn).magnitude2() {
            q[2]
        } else {
            q[3]
        },
    )
}

/// Check and correct the pivot point for the given points
fn corrected_pivot(points: [Vec2; 2], about: Vec2) -> Complex32 {
    let p0c = complex(points[0] - about);
    let p1c = complex(points[1] - about);

    complex(if p0c.norm() < 0.01 {
        -points[1]
    } else if p1c.norm() < 0.01 {
        -points[0]
    } else {
        about
    })
}

/// PrimGraphics custom drop ensured that any pending primitive is flushed
impl<'a, R, C> Drop for PrimGraphics<'a, R, C>
where
    R: gfx::Resources,
    C: gfx::CommandBuffer<R>,
{
    fn drop(&mut self) {
        if self.c2d.offset > 0 {
            self.flush();
        }
    }
}

//
//  Customized buffers for 2d prim rendering (modified from gfx_graphics/back_end.rs)
//
use gfx;
use gfx::format::{DepthStencil, Srgba8};
use gfx::pso::PipelineState;
use graphics::color::gamma_srgb_to_linear;
use graphics::context::Context;
use graphics::BACK_END_MAX_VERTEX_COUNT as BUFFER_SIZE;
use graphics::{draw_state, types::Color, types::Matrix2d, DrawState};
use shader_version::glsl::GLSL;
use shader_version::{OpenGL, Shaders};

pub struct Prims2d<R: gfx::Resources> {
    offset: usize,
    draw_state: DrawState,
    pos: gfx::handle::Buffer<R, PositionFormat>,
    color: gfx::handle::Buffer<R, ColorFormat>,
    colored: PsoStencil<PipelineState<R, pipe_colored::Meta>>,
}

impl<R: gfx::Resources> Prims2d<R> {
    pub fn new<F>(opengl: OpenGL, factory: &mut F) -> Self
    where
        F: gfx::Factory<R>,
    {
        use gfx::state::Rasterizer;
        use gfx::state::{Blend, Stencil};
        use gfx::traits::*;
        use gfx::Primitive;
        use shaders::colored;

        let glsl = opengl.to_glsl();

        let colored_program = factory
            .link_program(
                Shaders::new()
                    .set(GLSL::V1_20, colored::VERTEX_GLSL_120)
                    .set(GLSL::V1_50, colored::VERTEX_GLSL_150_CORE)
                    .get(glsl)
                    .unwrap(),
                Shaders::new()
                    .set(GLSL::V1_20, colored::FRAGMENT_GLSL_120)
                    .set(GLSL::V1_50, colored::FRAGMENT_GLSL_150_CORE)
                    .get(glsl)
                    .unwrap(),
            ).unwrap();

        let colored_pipeline = |factory: &mut F,
                                blend_preset: Blend,
                                stencil: Stencil,
                                color_mask: gfx::state::ColorMask|
         -> PipelineState<R, pipe_colored::Meta> {
            factory
                .create_pipeline_from_program(
                    &colored_program,
                    Primitive::TriangleList,
                    Rasterizer::new_fill(),
                    pipe_colored::Init {
                        pos: (),
                        color: (),
                        blend_target: ("o_Color", color_mask, blend_preset),
                        stencil_target: stencil,
                        blend_ref: (),
                        scissor: (),
                    },
                ).unwrap()
        };

        let colored = PsoStencil::new(factory, colored_pipeline);

        let buffer_pos = factory
            .create_buffer(
                BUFFER_SIZE * CHUNKS,
                gfx::buffer::Role::Vertex,
                gfx::memory::Usage::Dynamic,
                gfx::memory::Bind::empty(),
            ).expect("Could not create `buffer_pos`");
        let buffer_color = factory
            .create_buffer(
                BUFFER_SIZE * CHUNKS,
                gfx::buffer::Role::Vertex,
                gfx::memory::Usage::Dynamic,
                gfx::memory::Bind::empty(),
            ).expect("Could not create `buffer_color`");

        Prims2d {
            offset: 0,
            draw_state: Default::default(),
            pos: buffer_pos,
            color: buffer_color,
            colored: colored,
        }
    }
}

const CHUNKS: usize = 100;

gfx_defines! {
    vertex PositionFormat {
        pos: [f32; 2] = "pos",
    }

    vertex ColorFormat {
        color: [f32; 4] = "color",
    }
}

gfx_pipeline_base!( pipe_colored {
    pos: gfx::VertexBuffer<PositionFormat>,
    color: gfx::VertexBuffer<ColorFormat>,
    blend_target: gfx::BlendTarget<gfx::format::Srgba8>,
    stencil_target: gfx::StencilTarget<gfx::format::DepthStencil>,
    blend_ref: gfx::BlendRef,
    scissor: gfx::Scissor,
});

struct PsoBlend<T> {
    alpha: T,
    add: T,
    multiply: T,
    invert: T,
    none: T,
}

impl<T> PsoBlend<T> {
    fn blend(&mut self, blend: Option<draw_state::Blend>) -> &mut T {
        use graphics::draw_state::Blend;

        match blend {
            Some(Blend::Alpha) => &mut self.alpha,
            Some(Blend::Add) => &mut self.add,
            Some(Blend::Multiply) => &mut self.multiply,
            Some(Blend::Invert) => &mut self.invert,
            None => &mut self.none,
        }
    }
}

struct PsoStencil<T> {
    none: PsoBlend<T>,
    clip: PsoBlend<T>,
    inside: PsoBlend<T>,
    outside: PsoBlend<T>,
}

impl<T> PsoStencil<T> {
    fn new<Fact, F>(factory: &mut Fact, f: F) -> PsoStencil<T>
    where
        F: Fn(&mut Fact, gfx::state::Blend, gfx::state::Stencil, gfx::state::ColorMask) -> T,
    {
        use gfx::preset::blend;
        use gfx::state::{Blend, BlendChannel, Comparison, Equation, Factor, Stencil, StencilOp};

        let stencil = Stencil::new(
            Comparison::Always,
            0,
            (StencilOp::Keep, StencilOp::Keep, StencilOp::Keep),
        );
        let stencil_clip = Stencil::new(
            Comparison::Never,
            255,
            (StencilOp::Replace, StencilOp::Keep, StencilOp::Keep),
        );
        let stencil_inside = Stencil::new(
            Comparison::Equal,
            255,
            (StencilOp::Keep, StencilOp::Keep, StencilOp::Keep),
        );
        let stencil_outside = Stencil::new(
            Comparison::NotEqual,
            255,
            (StencilOp::Keep, StencilOp::Keep, StencilOp::Keep),
        );

        // Channel color masks.
        let mask_all = gfx::state::ColorMask::all();
        let mask_none = gfx::state::ColorMask::empty();

        // Fake disabled blending using the same pipeline.
        let no_blend = Blend {
            color: BlendChannel {
                equation: Equation::Add,
                source: Factor::One,
                destination: Factor::Zero,
            },
            alpha: BlendChannel {
                equation: Equation::Add,
                source: Factor::One,
                destination: Factor::Zero,
            },
        };

        PsoStencil {
            none: PsoBlend {
                alpha: f(factory, blend::ALPHA, stencil, mask_all),
                add: f(factory, blend::ADD, stencil, mask_all),
                multiply: f(factory, blend::MULTIPLY, stencil, mask_all),
                invert: f(factory, blend::INVERT, stencil, mask_all),
                none: f(factory, no_blend, stencil, mask_all),
            },
            clip: PsoBlend {
                alpha: f(factory, blend::ALPHA, stencil_clip, mask_none),
                add: f(factory, blend::ADD, stencil_clip, mask_none),
                multiply: f(factory, blend::MULTIPLY, stencil_clip, mask_none),
                invert: f(factory, blend::INVERT, stencil_clip, mask_none),
                none: f(factory, no_blend, stencil_clip, mask_none),
            },
            inside: PsoBlend {
                alpha: f(factory, blend::ALPHA, stencil_inside, mask_all),
                add: f(factory, blend::ADD, stencil_inside, mask_all),
                multiply: f(factory, blend::MULTIPLY, stencil_inside, mask_all),
                invert: f(factory, blend::INVERT, stencil_inside, mask_all),
                none: f(factory, no_blend, stencil_inside, mask_all),
            },
            outside: PsoBlend {
                alpha: f(factory, blend::ALPHA, stencil_outside, mask_all),
                add: f(factory, blend::ADD, stencil_outside, mask_all),
                multiply: f(factory, blend::MULTIPLY, stencil_outside, mask_all),
                invert: f(factory, blend::INVERT, stencil_outside, mask_all),
                none: f(factory, no_blend, stencil_outside, mask_all),
            },
        }
    }

    // Returns a PSO and stencil reference given a stencil and blend setting.
    fn stencil_blend(
        &mut self,
        stencil: Option<draw_state::Stencil>,
        blend: Option<draw_state::Blend>,
    ) -> (&mut T, u8) {
        use graphics::draw_state::Stencil;

        match stencil {
            None => (self.none.blend(blend), 0),
            Some(Stencil::Clip(val)) => (self.clip.blend(blend), val),
            Some(Stencil::Inside(val)) => (self.inside.blend(blend), val),
            Some(Stencil::Outside(val)) => (self.outside.blend(blend), val),
        }
    }
}
